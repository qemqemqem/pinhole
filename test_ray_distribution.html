<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Distribution Test - Pinhole Camera</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-result {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 4px solid;
        }
        .pass {
            background-color: #d4edda;
            color: #155724;
            border-left-color: #28a745;
        }
        .fail {
            background-color: #f8d7da;
            color: #721c24;
            border-left-color: #dc3545;
        }
        .critical-fail {
            background-color: #f8d7da;
            color: #721c24;
            border-left-color: #dc3545;
            font-weight: bold;
            border: 2px solid #dc3545;
        }
        .test-summary {
            font-weight: bold;
            margin-top: 25px;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .test-data {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 14px;
        }
        .visual-test {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
        }
        canvas {
            border: 1px solid #ccc;
            margin: 10px;
        }
        .test-section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #495057;
        }
    </style>
</head>
<body>
    <h1>🔬 Ray Distribution Analysis</h1>
    <p>Comprehensive testing to detect ray endpoint clustering and ensure proper pinhole camera physics.</p>
    
    <div id="test-results"></div>

    <script>
        // Same projection calculation as in pinhole.js
        function calculateProjection(startX, startY, pinholeX, pinholeY, projectionPlaneX) {
            const t = (projectionPlaneX - startX) / (pinholeX - startX);
            const endX = projectionPlaneX;
            const endY = startY + t * (pinholeY - startY);
            return { endX, endY };
        }

        function runRayDistributionTests() {
            const results = [];
            
            // Realistic simulation parameters
            const sourceX = 100, sourceY = 100, sourceWidth = 300, sourceHeight = 300;
            const pinholeX = 500, pinholeY = 250;
            const projectionX = 700, projectionWidth = 300, projectionHeight = 300;
            const projectionPlaneX = projectionX + projectionWidth * 0.75;
            
            console.log('Test Setup:', {
                source: `${sourceX},${sourceY} ${sourceWidth}x${sourceHeight}`,
                pinhole: `${pinholeX},${pinholeY}`,
                projectionPlane: projectionPlaneX
            });

            // Generate test rays from different source positions
            const testRays = [];
            const numTestRays = 50;
            
            for (let i = 0; i < numTestRays; i++) {
                const startX = sourceX + (i / (numTestRays - 1)) * sourceWidth; // Spread across width
                const startY = sourceY + Math.random() * sourceHeight;
                const projection = calculateProjection(startX, startY, pinholeX, pinholeY, projectionPlaneX);
                testRays.push({
                    startX, startY,
                    endX: projection.endX, 
                    endY: projection.endY
                });
            }

            // TEST 1: Critical - Check for X endpoint clustering
            const endXValues = testRays.map(ray => ray.endX);
            const uniqueXValues = [...new Set(endXValues.map(x => Math.round(x)))];
            const xClusteringTest = uniqueXValues.length > 1;
            
            results.push({
                name: "❌ CRITICAL: X Endpoint Distribution",
                passed: xClusteringTest,
                critical: true,
                description: "Ray endpoints must NOT all cluster at same X position",
                expected: "Multiple distinct X values",
                actual: `${uniqueXValues.length} unique X positions: [${uniqueXValues.slice(0,5).join(', ')}${uniqueXValues.length > 5 ? '...' : ''}]`,
                details: `This test catches the main bug visible in screenshots`,
                testData: endXValues.slice(0, 10).map(x => x.toFixed(2)).join(', ')
            });

            // TEST 2: Y endpoint spread verification
            const endYValues = testRays.map(ray => ray.endY);
            const yRange = Math.max(...endYValues) - Math.min(...endYValues);
            const ySpreadTest = yRange > 50; // Should have significant Y spread
            
            results.push({
                name: "Y Endpoint Spread",
                passed: ySpreadTest,
                description: "Ray endpoints should spread vertically on projection",
                expected: "Y range > 50 pixels",
                actual: `Y range = ${yRange.toFixed(1)} pixels`,
                details: `Min Y: ${Math.min(...endYValues).toFixed(1)}, Max Y: ${Math.max(...endYValues).toFixed(1)}`
            });

            // TEST 3: Inversion verification - left source should project right
            const leftmostRay = testRays.find(ray => ray.startX === Math.min(...testRays.map(r => r.startX)));
            const rightmostRay = testRays.find(ray => ray.startX === Math.max(...testRays.map(r => r.startX)));
            
            // In proper pinhole physics: left source → higher Y on projection (if pinhole is center)
            const inversionTest = leftmostRay.endY !== rightmostRay.endY;
            
            results.push({
                name: "Horizontal Inversion Physics",
                passed: inversionTest,
                description: "Left and right source points should project to different Y positions",
                expected: "Different Y endpoints for left vs right source",
                actual: `Left source(${leftmostRay.startX.toFixed(0)}) → Y=${leftmostRay.endY.toFixed(1)}, Right source(${rightmostRay.startX.toFixed(0)}) → Y=${rightmostRay.endY.toFixed(1)}`,
                details: `Y difference: ${Math.abs(leftmostRay.endY - rightmostRay.endY).toFixed(1)} pixels`
            });

            // TEST 4: Projection plane consistency
            const projectionPlaneTest = testRays.every(ray => Math.abs(ray.endX - projectionPlaneX) < 0.01);
            
            results.push({
                name: "Projection Plane Consistency",
                passed: projectionPlaneTest,
                description: "All rays should hit the same projection plane X coordinate",
                expected: `All endX ≈ ${projectionPlaneX}`,
                actual: projectionPlaneTest ? "All rays hit plane correctly" : "Some rays miss plane",
                details: `Expected X: ${projectionPlaneX}, Actual range: ${Math.min(...endXValues).toFixed(2)} - ${Math.max(...endXValues).toFixed(2)}`
            });

            // TEST 5: Ray distribution variance
            const xVariance = calculateVariance(testRays.map(r => r.startX));
            const yVariance = calculateVariance(endYValues);
            const varianceTest = yVariance > 10; // Should have good Y variance in projection
            
            results.push({
                name: "Projection Variance",
                passed: varianceTest,
                description: "Projected rays should have good variance (not all clustered)",
                expected: "Y variance > 10",
                actual: `Source X variance: ${xVariance.toFixed(1)}, Projection Y variance: ${yVariance.toFixed(1)}`,
                details: `Good variance indicates proper ray spreading`
            });

            // TEST 6: Visual distribution test
            const visualTestResult = createVisualDistributionTest(testRays, projectionPlaneX);
            results.push(visualTestResult);

            return results;
        }

        function calculateVariance(values) {
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
            return squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
        }

        function createVisualDistributionTest(rays, projectionPlaneX) {
            // Create visual representation
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            canvas.style.border = '1px solid #ccc';
            
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw projection plane
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(300, 0);
            ctx.lineTo(300, canvas.height);
            ctx.stroke();
            
            // Draw ray endpoints
            const scale = 0.5;
            rays.forEach((ray, i) => {
                const x = ray.endX * scale;
                const y = ray.endY * scale + 150; // Center vertically
                
                if (i === 0) ctx.fillStyle = '#dc3545'; // First ray red
                else if (i === rays.length - 1) ctx.fillStyle = '#28a745'; // Last ray green  
                else ctx.fillStyle = '#6c757d'; // Others gray
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Check clustering visually
            const endPositions = rays.map(r => ({ x: r.endX * scale, y: r.endY * scale + 150 }));
            const xSpread = Math.max(...endPositions.map(p => p.x)) - Math.min(...endPositions.map(p => p.x));
            const clusteringTest = xSpread > 10; // Should spread horizontally
            
            return {
                name: "Visual Distribution Analysis",
                passed: clusteringTest,
                description: "Visual check of ray endpoint distribution",
                expected: "Ray endpoints spread across projection area",
                actual: `X spread: ${xSpread.toFixed(1)}px (${clusteringTest ? 'Good' : 'CLUSTERED'})`,
                details: "See visualization below",
                canvas: canvas
            };
        }

        function displayResults(results) {
            const container = document.getElementById('test-results');
            let html = '';
            let passed = 0;
            let criticalFailed = false;

            results.forEach(result => {
                if (result.passed) passed++;
                if (result.critical && !result.passed) criticalFailed = true;
                
                const resultClass = result.critical && !result.passed ? 'critical-fail' : 
                                  result.passed ? 'pass' : 'fail';
                const icon = result.passed ? '✅' : result.critical ? '🚨' : '❌';
                
                html += `
                    <div class="test-result ${resultClass}">
                        <strong>${icon} ${result.name}</strong><br>
                        ${result.description}<br>
                        <strong>Expected:</strong> ${result.expected}<br>
                        <strong>Actual:</strong> ${result.actual}<br>
                        <em>${result.details}</em>
                        ${result.testData ? `<div class="test-data">Sample data: ${result.testData}</div>` : ''}
                    </div>
                `;
                
                if (result.canvas) {
                    html += `<div class="visual-test"><strong>Visual Test:</strong><br></div>`;
                }
            });

            // Add visual canvas if it exists
            const visualResult = results.find(r => r.canvas);
            
            const summaryClass = passed === results.length ? 'pass' : 'fail';
            const summaryIcon = criticalFailed ? '🚨 CRITICAL FAILURE' : 
                               passed === results.length ? '🎉 ALL TESTS PASSED' : 
                               '⚠️ SOME TESTS FAILED';
            
            html += `
                <div class="test-summary ${summaryClass}">
                    ${summaryIcon}<br>
                    Ray Distribution Test Results: ${passed}/${results.length} tests passed
                    ${criticalFailed ? '<br><br>⚠️ Critical ray clustering detected - fix projection math immediately!' : ''}
                    ${passed === results.length ? '<br>Ray projection physics are working correctly!' : ''}
                </div>
            `;

            container.innerHTML = html;
            
            if (visualResult && visualResult.canvas) {
                const visualDiv = container.querySelector('.visual-test');
                visualDiv.appendChild(visualResult.canvas);
            }
        }

        // Run tests when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const results = runRayDistributionTests();
            displayResults(results);
        });
    </script>
</body>
</html>